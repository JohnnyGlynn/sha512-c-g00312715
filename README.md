## SHA-512 Encryption in C - (G00312715) John Glynn
### This Repo contains...
test.txt - quick brown fox - 344 bits / 43 Byte file/

Expected test.txt SHA512 output: `07e547d9586f6a73f73fbac0435ed76951218fb7d0c8d788a309d785436bbb642e93a252a954f23912547d1e8a3b5ed6e1bfd7097821233fa0538f3db854fee6`

sha512.c - SHA512 algorithim implemented in C\
Makefile - Standardised code compilation and running of tests\
test.sh - Test file for sha512.c\
README.md - Overview of the repository, the Sha512 algorithim, and questions.

### How to run this project
`make sha512 ` - This will compile the C code into an executeable binary\
`make test` - This will run the tests.sh file to test that the sha512 binary functions as expected\
`make runtest` - This will run the sha512 binary against test.txt\
`make all` - This will compile and test the code

## SHA-512 Algorithim & importance

The Secure Hash Algorithim are a collection of cryptogrpahic hashing fucntions published by NIST ((United States) National Institue of Standards and Technology).

This repository focuses on the implementation of the SHA512 hashing function.

SHA512 works as follows.

A variable lenght input is provided to the function, the message is then padded into `n` number of 1024-bit message blocks (128 bytes) represented as 16 64 bit words. These padded blocks are then processed 1024 bits at a time. Due to the nature of the Secure Hash Algorithim, the next hash is relaint on the previous one, so to start the hashing process, there needs to be an initalised hash buffer which is generated by "taking the first sixty-four bits of the fractional parts of the square roots of the first eight prime numbers". The preprocessed blocks are then taken and passed though a series of rotation functions a total of 80 times, 1 time for each of the Constants defined in the algorithim, until it has generated 8 64 bit words that are appended together to make the final message digest [1]

## Questions (Max 500 words)
### Why can't we reverse the SHA512 algorithm to retrieve the original message from a hash digest?

The SHA512 Algorithim is an example of a cryptographic hash, which is not the same as an enccryption function. While encryption functions are meant to be "unlocked" by the use of Keys, (Public key for encrypting the data, and Private key for decrypting), Hashing algorithims are a 1 way system, once the data goes through, it is nearly impossible to find out the origional input message for a number of reasons, for Example, Bit Dependency & Avalanching. Every bit of the the output is reliant on every bit of the input, meaning the output has to be solved in its entirety rather than breaking it up, and with Bit dependancy comes Avalanching, changing 1 bit of the input should affect every bit of the output. [2][3]

### Can you design an algorithm that, given enough time, will find input messages that give each of the possible 512-bit strings?

It is possible given enough time that you could compute all possible 512 bit strings, however due to the collision resistant nature of the SHA512 algorithim, the amount of time would be very significant.

There are 2<sup>(512)</sup> possible 512 bit strings, this equates to about `1.340781e+154` possible 512-bit strings.
That euqates to `13,407,809,999,999,998,952,880,544,632,216,944,472,008,416,832,352,536,992,168,040,136,592,752,456,312,408,904,552,048,552,752,144,632,312,600,272,560,816,168,504,768,072,336,536,208,720,600,400,216,112,104`.

The Bitcoin network after 11 years of activity is capable of carrying out 74 quintillion or 74,000,000,000,000,000,000 hashes a second.

That means if you were to dedicate all the hashrate of the entire bitcoin network at just calculating 512 bit strings, it would take  `1.340781e+154` / 74,000,000,000,000,000,000 = `1.811866e+135`, which equates to 5,032,961 hours or 209706.7 days or 574.53 years.

### How difficult is it to find a hash digest beginning with at least twelve zeros?

### References
[1] https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
[2] https://en.wikipedia.org/wiki/Avalanche_effect\
[3] https://en.wikipedia.org/wiki/Cryptographic_hash_function\
